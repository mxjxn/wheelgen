<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Controls Testing - WheelGen</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #ffffff;
            margin-bottom: 30px;
        }
        
        .testing-section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #444;
        }
        
        .testing-section h2 {
            color: #4CAF50;
            margin-top: 0;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .color-wheel-container {
            background: #333;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .sliders-container {
            background: #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .slider-group {
            margin-bottom: 20px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
            font-weight: 500;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .color-preview {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            margin: 20px auto;
            border: 2px solid #666;
            background: #000;
        }
        
        .color-values {
            background: #444;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .color-values div {
            margin-bottom: 5px;
        }
        
        .testing-info {
            background: #1e3a5f;
            border: 1px solid #3a5f8a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .testing-info h3 {
            color: #64B5F6;
            margin-top: 0;
        }
        
        .testing-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .testing-info li {
            margin-bottom: 5px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-working { background: #4CAF50; }
        .status-testing { background: #FF9800; }
        .status-planned { background: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Color Controls Testing</h1>
        
        <div class="testing-info">
            <h3>Testing Status</h3>
            <ul>
                <li><span class="status-indicator status-testing"></span>Color Wheel - In Development</li>
                <li><span class="status-indicator status-planned"></span>Brightness Slider - Planned</li>
                <li><span class="status-indicator status-planned"></span>Saturation Slider - Planned</li>
                <li><span class="status-indicator status-planned"></span>Multi-Point Color Wheel - Planned</li>
                <li><span class="status-indicator status-planned"></span>Palette Color Selector - Planned</li>
            </ul>
        </div>
        
        <div class="testing-section">
            <h2>Single Color Wheel</h2>
            <div class="controls-grid">
                <div class="color-wheel-container">
                    <div id="color-wheel-canvas"></div>
                    <div class="color-preview" id="color-preview"></div>
                </div>
                
                <div class="sliders-container">
                    <div class="slider-group">
                        <label for="hue-slider">Hue: <span id="hue-value">0</span>Â°</label>
                        <input type="range" id="hue-slider" class="slider" min="0" max="360" value="0">
                    </div>
                    
                    <div class="slider-group">
                        <label for="saturation-slider">Saturation: <span id="saturation-value">100</span>%</label>
                        <input type="range" id="saturation-slider" class="slider" min="0" max="100" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label for="brightness-slider">Brightness: <span id="brightness-value">100</span>%</label>
                        <input type="range" id="brightness-slider" class="slider" min="0" max="100" value="100">
                    </div>
                    
                    <div class="color-values">
                        <div>HSB: <span id="hsb-values">0Â°, 100%, 100%</span></div>
                        <div>RGB: <span id="rgb-values">255, 0, 0</span></div>
                        <div>Hex: <span id="hex-values">#FF0000</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="testing-section">
            <h2>Multi-Point Color Wheel</h2>
            <div class="controls-grid">
                <div class="color-wheel-container">
                    <div id="multi-color-wheel-canvas"></div>
                    <div style="margin-top: 20px;">
                        <label for="harmony-mode">Harmony Mode:</label>
                        <select id="harmony-mode" style="margin-left: 10px; padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 4px;">
                            <option value="complementary">Complementary</option>
                            <option value="triadic">Triadic</option>
                            <option value="tetradic">Tetradic</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                </div>
                
                <div class="sliders-container">
                    <h3 style="color: #4CAF50; margin-top: 0;">Generated Palette</h3>
                    <div id="palette-preview" style="display: flex; gap: 10px; margin-bottom: 20px;">
                        <!-- Palette colors will be generated here -->
                    </div>
                    
                    <div class="color-values">
                        <div>Harmony Mode: <span id="current-harmony">Complementary</span></div>
                        <div>Color Count: <span id="color-count">2</span></div>
                        <div>Base Hue: <span id="base-hue">0</span>Â°</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="testing-section">
            <h2>Testing Notes</h2>
            <div style="background: #444; padding: 15px; border-radius: 8px;">
                <h4 style="color: #4CAF50; margin-top: 0;">Current Focus:</h4>
                <ul>
                    <li>Implementing p5.js-based color wheel with HSB color space</li>
                    <li>Mouse interaction for hue/saturation selection</li>
                    <li>Real-time color preview and value updates</li>
                    <li>Integration with brightness/saturation sliders</li>
                </ul>
                
                <h4 style="color: #FF9800; margin-top: 20px;">Next Steps:</h4>
                <ul>
                    <li>Add multi-point color wheel with harmony modes</li>
                    <li>Implement palette generation based on harmony rules</li>
                    <li>Create compact color swatch components</li>
                    <li>Test performance and smooth interactions</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Color Wheel Implementation
        let colorWheelSketch;
        let multiColorWheelSketch;
        let currentColor = { h: 0, s: 100, b: 100 };
        let harmonyMode = 'complementary';
        let harmonyColors = [];
        
        // Single Color Wheel
        colorWheelSketch = new p5((p) => {
            let wheelSize = 200;
            let centerX, centerY;
            let isDragging = false;
            
            p.setup = () => {
                let canvas = p.createCanvas(wheelSize, wheelSize);
                canvas.parent('color-wheel-canvas');
                centerX = wheelSize / 2;
                centerY = wheelSize / 2;
                p.colorMode(p.HSB, 360, 100, 100);
                drawColorWheel();
            };
            
            p.draw = () => {
                if (!isDragging) {
                    drawColorWheel();
                }
            };
            
            function drawColorWheel() {
                p.background(0);
                
                // Draw HSB color wheel
                for (let angle = 0; angle < 360; angle += 1) {
                    for (let radius = 0; radius < wheelSize / 2 - 20; radius += 2) {
                        let x = centerX + p.cos(p.radians(angle)) * radius;
                        let y = centerY + p.sin(p.radians(angle)) * radius;
                        
                        let hue = angle;
                        let saturation = p.map(radius, 0, wheelSize / 2 - 20, 0, 100); // Inverted: saturated on edges
                        let brightness = currentColor.b;
                        
                        p.stroke(hue, saturation, brightness);
                        p.point(x, y);
                    }
                }
                
                // Draw current color indicator
                let indicatorRadius = 8;
                let indicatorX = centerX + p.cos(p.radians(currentColor.h)) * p.map(currentColor.s, 0, 100, wheelSize / 2 - 20, 0); // Inverted mapping
                let indicatorY = centerY + p.sin(p.radians(currentColor.h)) * p.map(currentColor.s, 0, 100, wheelSize / 2 - 20, 0); // Inverted mapping
                
                p.fill(255);
                p.noStroke();
                p.circle(indicatorX, indicatorY, indicatorRadius * 2);
                p.fill(currentColor.h, currentColor.s, currentColor.b);
                p.circle(indicatorX, indicatorY, indicatorRadius * 1.5);
            }
            
            p.mousePressed = () => {
                if (p.mouseX >= 0 && p.mouseX < wheelSize && p.mouseY >= 0 && p.mouseY < wheelSize) {
                    isDragging = true;
                    updateColorFromMouse();
                }
            };
            
            p.mouseDragged = () => {
                if (isDragging) {
                    updateColorFromMouse();
                }
            };
            
            p.mouseReleased = () => {
                isDragging = false;
            };
            
            function updateColorFromMouse() {
                let dx = p.mouseX - centerX;
                let dy = p.mouseY - centerY;
                let distance = p.sqrt(dx * dx + dy * dy);
                let maxRadius = wheelSize / 2 - 20;
                
                if (distance <= maxRadius) {
                    let angle = p.degrees(p.atan2(dy, dx));
                    if (angle < 0) angle += 360;
                    
                    currentColor.h = angle;
                    currentColor.s = p.map(distance, 0, maxRadius, 0, 100); // Inverted: saturated on edges
                    
                    updateUI();
                }
            }
        });
        
        // Multi-Point Color Wheel
        multiColorWheelSketch = new p5((p) => {
            let wheelSize = 250;
            let centerX, centerY;
            let colorPoints = [];
            let isDragging = false;
            let draggedPoint = -1;
            
            p.setup = () => {
                let canvas = p.createCanvas(wheelSize, wheelSize);
                canvas.parent('multi-color-wheel-canvas');
                centerX = wheelSize / 2;
                centerY = wheelSize / 2;
                p.colorMode(p.HSB, 360, 100, 100);
                initializeHarmonyColors();
                drawMultiColorWheel();
            };
            
            p.draw = () => {
                if (!isDragging) {
                    drawMultiColorWheel();
                }
            };
            
            function initializeHarmonyColors() {
                colorPoints = [];
                let baseHue = p.random(360);
                
                switch (harmonyMode) {
                    case 'complementary':
                        colorPoints = [
                            { h: baseHue, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 180) % 360, s: 100, b: 100, x: 0, y: 0 }
                        ];
                        break;
                    case 'triadic':
                        colorPoints = [
                            { h: baseHue, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 120) % 360, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 240) % 360, s: 100, b: 100, x: 0, y: 0 }
                        ];
                        break;
                    case 'tetradic':
                        colorPoints = [
                            { h: baseHue, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 90) % 360, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 180) % 360, s: 100, b: 100, x: 0, y: 0 },
                            { h: (baseHue + 270) % 360, s: 100, b: 100, x: 0, y: 0 }
                        ];
                        break;
                }
                
                updateColorPointPositions();
                updatePalettePreview();
            }
            
            function updateColorPointPositions() {
                let maxRadius = wheelSize / 2 - 30;
                colorPoints.forEach((point, index) => {
                    point.x = centerX + p.cos(p.radians(point.h)) * maxRadius;
                    point.y = centerY + p.sin(p.radians(point.h)) * maxRadius;
                });
            }
            
            function drawMultiColorWheel() {
                p.background(0);
                
                // Draw HSB color wheel
                for (let angle = 0; angle < 360; angle += 2) {
                    for (let radius = 0; radius < wheelSize / 2 - 30; radius += 3) {
                        let x = centerX + p.cos(p.radians(angle)) * radius;
                        let y = centerY + p.sin(p.radians(angle)) * radius;
                        
                        let hue = angle;
                        let saturation = p.map(radius, 0, wheelSize / 2 - 30, 0, 100); // Inverted: saturated on edges
                        let brightness = 100;
                        
                        p.stroke(hue, saturation, brightness);
                        p.point(x, y);
                    }
                }
                
                // Draw harmony lines
                if (harmonyMode !== 'custom' && colorPoints.length > 1) {
                    p.stroke(255, 50);
                    p.strokeWeight(2);
                    for (let i = 0; i < colorPoints.length; i++) {
                        let next = (i + 1) % colorPoints.length;
                        p.line(colorPoints[i].x, colorPoints[i].y, colorPoints[next].x, colorPoints[next].y);
                    }
                }
                
                // Draw color points
                colorPoints.forEach((point, index) => {
                    p.fill(255);
                    p.noStroke();
                    p.circle(point.x, point.y, 16);
                    p.fill(point.h, point.s, point.b);
                    p.circle(point.x, point.y, 12);
                    
                    // Draw point number
                    p.fill(255);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(10);
                    p.text(index + 1, point.x, point.y);
                });
            }
            
            p.mousePressed = () => {
                if (p.mouseX >= 0 && p.mouseX < wheelSize && p.mouseY >= 0 && p.mouseY < wheelSize) {
                    // Check if clicking on a color point
                    for (let i = 0; i < colorPoints.length; i++) {
                        let distance = p.dist(p.mouseX, p.mouseY, colorPoints[i].x, colorPoints[i].y);
                        if (distance < 16) {
                            isDragging = true;
                            draggedPoint = i;
                            return;
                        }
                    }
                    
                    // If not clicking on a point, add new point (custom mode only)
                    if (harmonyMode === 'custom') {
                        let dx = p.mouseX - centerX;
                        let dy = p.mouseY - centerY;
                        let distance = p.sqrt(dx * dx + dy * dy);
                        let maxRadius = wheelSize / 2 - 30;
                        
                        if (distance <= maxRadius && colorPoints.length < 6) {
                            let angle = p.degrees(p.atan2(dy, dx));
                            if (angle < 0) angle += 360;
                            
                            let newPoint = {
                                h: angle,
                                s: p.map(distance, 0, maxRadius, 0, 100), // Inverted: saturated on edges
                                b: 100,
                                x: p.mouseX,
                                y: p.mouseY
                            };
                            colorPoints.push(newPoint);
                            updatePalettePreview();
                        }
                    }
                }
            };
            
            p.mouseDragged = () => {
                if (isDragging && draggedPoint >= 0) {
                    let dx = p.mouseX - centerX;
                    let dy = p.mouseY - centerY;
                    let distance = p.sqrt(dx * dx + dy * dy);
                    let maxRadius = wheelSize / 2 - 30;
                    
                    if (distance <= maxRadius) {
                        let angle = p.degrees(p.atan2(dy, dx));
                        if (angle < 0) angle += 360;
                        
                        colorPoints[draggedPoint].h = angle;
                        colorPoints[draggedPoint].s = p.map(distance, 0, maxRadius, 0, 100); // Inverted: saturated on edges
                        colorPoints[draggedPoint].x = p.mouseX;
                        colorPoints[draggedPoint].y = p.mouseY;
                        
                        updatePalettePreview();
                    }
                }
            };
            
            p.mouseReleased = () => {
                isDragging = false;
                draggedPoint = -1;
            };
            
            function updatePalettePreview() {
                let paletteContainer = document.getElementById('palette-preview');
                paletteContainer.innerHTML = '';
                
                colorPoints.forEach((point, index) => {
                    let colorDiv = document.createElement('div');
                    colorDiv.style.width = '40px';
                    colorDiv.style.height = '40px';
                    colorDiv.style.backgroundColor = `hsl(${point.h}, ${point.s}%, ${point.b}%)`;
                    colorDiv.style.border = '2px solid #666';
                    colorDiv.style.borderRadius = '4px';
                    colorDiv.style.cursor = 'pointer';
                    colorDiv.title = `Color ${index + 1}: HSB(${Math.round(point.h)}, ${Math.round(point.s)}, ${Math.round(point.b)})`;
                    paletteContainer.appendChild(colorDiv);
                });
                
                // Update harmony info
                document.getElementById('current-harmony').textContent = harmonyMode;
                document.getElementById('color-count').textContent = colorPoints.length;
                document.getElementById('base-hue').textContent = Math.round(colorPoints[0]?.h || 0);
            }
        });
        
        // UI Update Functions
        function updateUI() {
            // Update sliders
            document.getElementById('hue-slider').value = currentColor.h;
            document.getElementById('saturation-slider').value = currentColor.s;
            document.getElementById('brightness-slider').value = currentColor.b;
            
            // Update labels
            document.getElementById('hue-value').textContent = Math.round(currentColor.h);
            document.getElementById('saturation-value').textContent = Math.round(currentColor.s);
            document.getElementById('brightness-value').textContent = Math.round(currentColor.b);
            
            // Update color preview
            let preview = document.getElementById('color-preview');
            preview.style.backgroundColor = `hsl(${currentColor.h}, ${currentColor.s}%, ${currentColor.b}%)`;
            
            // Update color values
            let rgb = hsbToRgb(currentColor.h, currentColor.s, currentColor.b);
            let hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            
            document.getElementById('hsb-values').textContent = `${Math.round(currentColor.h)}Â°, ${Math.round(currentColor.s)}%, ${Math.round(currentColor.b)}%`;
            document.getElementById('rgb-values').textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
            document.getElementById('hex-values').textContent = hex;
        }
        
        // Color conversion functions
        function hsbToRgb(h, s, b) {
            h = h / 360;
            s = s / 100;
            b = b / 100;
            
            let r, g, blue;
            let i = Math.floor(h * 6);
            let f = h * 6 - i;
            let p = b * (1 - s);
            let q = b * (1 - f * s);
            let t = b * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = b, g = t, blue = p; break;
                case 1: r = q, g = b, blue = p; break;
                case 2: r = p, g = b, blue = t; break;
                case 3: r = p, g = q, blue = b; break;
                case 4: r = t, g = p, blue = b; break;
                case 5: r = b, g = p, blue = q; break;
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(blue * 255)
            };
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }
        
        // Event listeners
        document.getElementById('hue-slider').addEventListener('input', (e) => {
            currentColor.h = parseFloat(e.target.value);
            updateUI();
        });
        
        document.getElementById('saturation-slider').addEventListener('input', (e) => {
            currentColor.s = parseFloat(e.target.value);
            updateUI();
        });
        
        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            currentColor.b = parseFloat(e.target.value);
            updateUI();
        });
        
        document.getElementById('harmony-mode').addEventListener('change', (e) => {
            harmonyMode = e.target.value;
            multiColorWheelSketch.initializeHarmonyColors();
        });
        
        // Initialize UI
        updateUI();
    </script>
</body>
</html>
