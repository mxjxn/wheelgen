<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L-Stroke Color Tools Testing - WheelGen</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #ffffff;
            margin-bottom: 30px;
        }
        
        .testing-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .testing-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 25px;
            border: 1px solid #444;
        }
        
        .testing-section h2 {
            color: #4CAF50;
            margin-top: 0;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            font-size: 1.4em;
        }
        
        .l-stroke-canvas {
            background: #333;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .color-controls {
            background: #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .color-wheel-container {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
            font-weight: 500;
            font-size: 14px;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .color-preview {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            margin: 15px auto;
            border: 2px solid #666;
            background: #000;
        }
        
        .color-values {
            background: #444;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .color-values div {
            margin-bottom: 4px;
        }
        
        .palette-swatches {
            display: flex;
            gap: 8px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .palette-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #666;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .palette-swatch:hover {
            border-color: #4CAF50;
            transform: scale(1.1);
        }
        
        .palette-swatch.selected {
            border-color: #4CAF50;
            border-width: 3px;
        }
        
        .harmony-controls {
            margin-bottom: 20px;
        }
        
        .harmony-controls select {
            width: 100%;
            padding: 8px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .generate-button {
            width: 100%;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        .generate-button:hover {
            background: #45a049;
        }
        
        .generate-button:active {
            background: #3d8b40;
        }
        
        .info-panel {
            background: #1e3a5f;
            border: 1px solid #3a5f8a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .info-panel h3 {
            color: #64B5F6;
            margin-top: 0;
        }
        
        .info-panel p {
            margin: 10px 0;
            line-height: 1.5;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-working { background: #4CAF50; }
        .status-testing { background: #FF9800; }
        
        .tool-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .tool-card {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #444;
        }
        
        .tool-card h4 {
            color: #4CAF50;
            margin-top: 0;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ L-Stroke Color Tools Testing</h1>
        
        <div class="info-panel">
            <h3>Testing Overview</h3>
            <p>This page tests different color selection tools with the L-stroke rendering function. Each section demonstrates a different approach to color selection and how it affects the final L-stroke appearance.</p>
            <p><span class="status-indicator status-working"></span>Color Wheel - Interactive HSB color selection</p>
            <p><span class="status-indicator status-working"></span>Palette Generator - Harmony-based color palettes</p>
        </div>
        
        <div class="testing-grid">
            <!-- Color Wheel Section -->
            <div class="testing-section">
                <h2>ðŸŽ¯ Color Wheel Control</h2>
                <div class="l-stroke-canvas">
                    <div id="color-wheel-l-stroke"></div>
                </div>
                <div class="color-controls">
                    <div class="color-wheel-container">
                        <div id="color-wheel-canvas"></div>
                        <div class="color-preview" id="color-wheel-preview"></div>
                    </div>
                    
                    <div class="slider-group">
                        <label for="hue-slider">Hue: <span id="hue-value">0</span>Â°</label>
                        <input type="range" id="hue-slider" class="slider" min="0" max="360" value="0">
                    </div>
                    
                    <div class="slider-group">
                        <label for="saturation-slider">Saturation: <span id="saturation-value">100</span>%</label>
                        <input type="range" id="saturation-slider" class="slider" min="0" max="100" value="100">
                    </div>
                    
                    <div class="slider-group">
                        <label for="brightness-slider">Brightness: <span id="brightness-value">100</span>%</label>
                        <input type="range" id="brightness-slider" class="slider" min="0" max="100" value="100">
                    </div>
                    
                    <div class="color-values">
                        <div>HSB: <span id="hsb-values">0Â°, 100%, 100%</span></div>
                        <div>RGB: <span id="rgb-values">255, 0, 0</span></div>
                        <div>Hex: <span id="hex-values">#FF0000</span></div>
                    </div>
                </div>
            </div>
            
            <!-- Palette Generator Section -->
            <div class="testing-section">
                <h2>ðŸŽ¨ Palette Generator</h2>
                <div class="l-stroke-canvas">
                    <div id="palette-l-stroke"></div>
                </div>
                <div class="color-controls">
                    <div class="harmony-controls">
                        <label for="harmony-mode">Harmony Mode:</label>
                        <select id="harmony-mode">
                            <option value="complementary">Complementary</option>
                            <option value="triadic">Triadic</option>
                            <option value="tetradic">Tetradic</option>
                            <option value="analogous">Analogous</option>
                            <option value="random">Random</option>
                        </select>
                    </div>
                    
                    <button class="generate-button" id="generate-palette">Generate New Palette</button>
                    
                    <div class="palette-swatches" id="palette-swatches">
                        <!-- Palette colors will be generated here -->
                    </div>
                    
                    <div class="color-values">
                        <div>Selected Color: <span id="selected-color-label">A</span></div>
                        <div>HSB: <span id="palette-hsb-values">0Â°, 100%, 100%</span></div>
                        <div>RGB: <span id="palette-rgb-values">255, 0, 0</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tool-comparison">
            <div class="tool-card">
                <h4>Color Wheel Tool</h4>
                <p>Interactive HSB color wheel with real-time L-stroke preview. Drag to select hue and saturation, use sliders for fine-tuning.</p>
                <ul>
                    <li>Direct color selection</li>
                    <li>Real-time preview</li>
                    <li>Precise HSB control</li>
                </ul>
            </div>
            
            <div class="tool-card">
                <h4>Palette Generator</h4>
                <p>Harmony-based palette generation with multiple color options. Select from generated palettes to see different L-stroke variations.</p>
                <ul>
                    <li>Color harmony rules</li>
                    <li>Multiple color options</li>
                    <li>Consistent color relationships</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // L-Stroke Drawing Function (from the codebase)
        function drawCalligraphyLStroke(p, options) {
            const {
                w,
                h,
                offsets,
                saturations,
                colors,
                baseColor,
                strokeWidth = 0.25,
                segments = 7,
                upwardLength = 1.0,
                size = 1.0,
                rotation = 0,
                progress = 1.0,
            } = options;

            p.strokeWeight(strokeWidth);
            p.noFill();

            // Apply rotation transformation
            p.push();
            p.rotate(rotation);

            const base_p1 = { x: (w / 2) * size, y: 0 };
            const base_p2 = { x: (-w / 2) * size, y: 0 };
            const stemLength = h * upwardLength * size;
            const base_p3 = { x: base_p2.x - stemLength * Math.cos(Math.PI / 4), y: base_p2.y - stemLength * Math.sin(Math.PI / 4) };

            const len1 = Math.hypot(base_p1.x - base_p2.x, base_p1.y - base_p2.y);
            const len2 = Math.hypot(base_p2.x - base_p3.x, base_p2.y - base_p3.y);
            const totalLength = len1 + len2;

            for (let i = 0; i < offsets.length; i++) {
                const offset = offsets[i];
                const { startAlpha, endAlpha } = saturations[i];
                const strokeColor = colors ? colors[i] : baseColor;

                const p1 = { x: base_p1.x, y: base_p1.y + offset };
                const p2 = { x: base_p2.x, y: base_p2.y + offset };

                for (let j = 0; j < segments; j++) {
                    const t = j / segments;
                    if (t > progress) break;
                    const x1 = p.lerp(p1.x, p2.x, t);
                    const y1 = p.lerp(p1.y, p2.y, t);
                    const x2 = p.lerp(p1.x, p2.x, (j + 1) / segments);
                    const y2 = p.lerp(p1.y, p2.y, (j + 1) / segments);
                    const totalT = (t * len1) / totalLength;
                    const currentAlpha = p.lerp(startAlpha, endAlpha, totalT);
                    
                    // Properly read RGB values regardless of current color mode
                    p.colorMode(p.RGB, 255);
                    const r = Math.round(p.red(strokeColor));
                    const g = Math.round(p.green(strokeColor));
                    const b = Math.round(p.blue(strokeColor));
                    p.colorMode(p.HSB, 360, 100, 100); // Restore HSB mode
                    
                    p.stroke(r, g, b, currentAlpha);
                    p.line(x1, y1, x2, y2);
                }

                const stem_p1 = { x: p2.x, y: p2.y };
                const stem_p2 = { x: base_p3.x, y: base_p3.y + offset };

                for (let j = 0; j < segments; j++) {
                    const t = j / segments;
                    if (t > progress) break;
                    const x1 = p.lerp(stem_p1.x, stem_p2.x, t);
                    const y1 = p.lerp(stem_p1.y, stem_p2.y, t);
                    const x2 = p.lerp(stem_p1.x, stem_p2.x, (j + 1) / segments);
                    const y2 = p.lerp(stem_p1.y, stem_p2.y, (j + 1) / segments);
                    const totalT = (len1 + t * len2) / totalLength;
                    const currentAlpha = p.lerp(startAlpha, endAlpha, totalT);
                    
                    // Properly read RGB values regardless of current color mode
                    p.colorMode(p.RGB, 255);
                    const r = Math.round(p.red(strokeColor));
                    const g = Math.round(p.green(strokeColor));
                    const b = Math.round(p.blue(strokeColor));
                    p.colorMode(p.HSB, 360, 100, 100); // Restore HSB mode
                    
                    p.stroke(r, g, b, currentAlpha);
                    p.line(x1, y1, x2, y2);
                }
            }

            p.pop();
        }

        // Global variables
        let colorWheelSketch, paletteSketch;
        let colorWheelLStrokeSketch, paletteLStrokeSketch;
        let currentColor = { h: 0, s: 100, b: 100 };
        let currentPalette = [];
        let selectedPaletteIndex = 0;
        let harmonyMode = 'complementary';

        // Color conversion functions
        function hsbToRgb(h, s, b) {
            h = h / 360;
            s = s / 100;
            b = b / 100;
            
            let r, g, blue;
            let i = Math.floor(h * 6);
            let f = h * 6 - i;
            let p = b * (1 - s);
            let q = b * (1 - f * s);
            let t = b * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = b, g = t, blue = p; break;
                case 1: r = q, g = b, blue = p; break;
                case 2: r = p, g = b, blue = t; break;
                case 3: r = p, g = q, blue = b; break;
                case 4: r = t, g = p, blue = b; break;
                case 5: r = b, g = p, blue = q; break;
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(blue * 255)
            };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        // Generate palette based on harmony mode
        function generateHarmonyPalette(mode) {
            const palette = [];
            const baseHue = Math.random() * 360;
            
            switch (mode) {
                case 'complementary':
                    palette.push(
                        { h: baseHue, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 180) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 }
                    );
                    break;
                case 'triadic':
                    palette.push(
                        { h: baseHue, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 120) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 240) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 }
                    );
                    break;
                case 'tetradic':
                    palette.push(
                        { h: baseHue, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 90) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 180) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 270) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 }
                    );
                    break;
                case 'analogous':
                    palette.push(
                        { h: baseHue, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 30) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 60) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 },
                        { h: (baseHue + 90) % 360, s: 70 + Math.random() * 30, b: 80 + Math.random() * 20 }
                    );
                    break;
                case 'random':
                    for (let i = 0; i < 4; i++) {
                        palette.push({
                            h: Math.random() * 360,
                            s: 50 + Math.random() * 50,
                            b: 60 + Math.random() * 40
                        });
                    }
                    break;
            }
            
            return palette;
        }

        // Color Wheel Sketch
        colorWheelSketch = new p5((p) => {
            let wheelSize = 150;
            let centerX, centerY;
            let isDragging = false;
            
            p.setup = () => {
                let canvas = p.createCanvas(wheelSize, wheelSize);
                canvas.parent('color-wheel-canvas');
                centerX = wheelSize / 2;
                centerY = wheelSize / 2;
                p.colorMode(p.HSB, 360, 100, 100);
                drawColorWheel();
            };
            
            p.draw = () => {
                if (!isDragging) {
                    drawColorWheel();
                }
            };
            
            function drawColorWheel() {
                p.background(0);
                
                // Draw HSB color wheel
                for (let angle = 0; angle < 360; angle += 2) {
                    for (let radius = 0; radius < wheelSize / 2 - 15; radius += 2) {
                        let x = centerX + p.cos(p.radians(angle)) * radius;
                        let y = centerY + p.sin(p.radians(angle)) * radius;
                        
                        let hue = angle;
                        let saturation = p.map(radius, 0, wheelSize / 2 - 15, 0, 100);
                        let brightness = currentColor.b;
                        
                        p.stroke(hue, saturation, brightness);
                        p.point(x, y);
                    }
                }
                
                // Draw current color indicator
                let indicatorRadius = 6;
                let indicatorX = centerX + p.cos(p.radians(currentColor.h)) * p.map(currentColor.s, 0, 100, wheelSize / 2 - 15, 0);
                let indicatorY = centerY + p.sin(p.radians(currentColor.h)) * p.map(currentColor.s, 0, 100, wheelSize / 2 - 15, 0);
                
                p.fill(255);
                p.noStroke();
                p.circle(indicatorX, indicatorY, indicatorRadius * 2);
                p.fill(currentColor.h, currentColor.s, currentColor.b);
                p.circle(indicatorX, indicatorY, indicatorRadius * 1.5);
            }
            
            p.mousePressed = () => {
                if (p.mouseX >= 0 && p.mouseX < wheelSize && p.mouseY >= 0 && p.mouseY < wheelSize) {
                    isDragging = true;
                    updateColorFromMouse();
                }
            };
            
            p.mouseDragged = () => {
                if (isDragging) {
                    updateColorFromMouse();
                }
            };
            
            p.mouseReleased = () => {
                isDragging = false;
            };
            
            function updateColorFromMouse() {
                let dx = p.mouseX - centerX;
                let dy = p.mouseY - centerY;
                let distance = p.sqrt(dx * dx + dy * dy);
                let maxRadius = wheelSize / 2 - 15;
                
                if (distance <= maxRadius) {
                    let angle = p.degrees(p.atan2(dy, dx));
                    if (angle < 0) angle += 360;
                    
                    currentColor.h = angle;
                    currentColor.s = p.map(distance, 0, maxRadius, 0, 100);
                    
                    updateColorWheelUI();
                    updateColorWheelLStroke();
                }
            }
        });

        // Color Wheel L-Stroke Sketch
        colorWheelLStrokeSketch = new p5((p) => {
            p.setup = () => {
                let canvas = p.createCanvas(200, 200);
                canvas.parent('color-wheel-l-stroke');
                p.colorMode(p.HSB, 360, 100, 100);
                updateColorWheelLStroke();
            };
            
            function drawLStroke() {
                p.background(20, 20, 20);
                p.translate(100, 100);
                
                // Create color from current HSB values
                const strokeColor = p.color(currentColor.h, currentColor.s, currentColor.b);
                
                // L-stroke options
                const options = {
                    w: 60,
                    h: 80,
                    offsets: [0, -2, -4],
                    saturations: [
                        { startAlpha: 255, endAlpha: 200 },
                        { startAlpha: 200, endAlpha: 150 },
                        { startAlpha: 150, endAlpha: 100 }
                    ],
                    baseColor: strokeColor,
                    strokeWidth: 2,
                    segments: 10,
                    upwardLength: 0.8,
                    size: 1.2,
                    rotation: 0,
                    progress: 1.0
                };
                
                drawCalligraphyLStroke(p, options);
            }
            
            p.draw = drawLStroke;
        });

        // Palette L-Stroke Sketch
        paletteLStrokeSketch = new p5((p) => {
            p.setup = () => {
                let canvas = p.createCanvas(200, 200);
                canvas.parent('palette-l-stroke');
                p.colorMode(p.HSB, 360, 100, 100);
                updatePaletteLStroke();
            };
            
            function drawLStroke() {
                p.background(20, 20, 20);
                p.translate(100, 100);
                
                if (currentPalette.length > 0) {
                    const selectedColor = currentPalette[selectedPaletteIndex];
                    const strokeColor = p.color(selectedColor.h, selectedColor.s, selectedColor.b);
                    
                    // L-stroke options
                    const options = {
                        w: 60,
                        h: 80,
                        offsets: [0, -2, -4],
                        saturations: [
                            { startAlpha: 255, endAlpha: 200 },
                            { startAlpha: 200, endAlpha: 150 },
                            { startAlpha: 150, endAlpha: 100 }
                        ],
                        baseColor: strokeColor,
                        strokeWidth: 2,
                        segments: 10,
                        upwardLength: 0.8,
                        size: 1.2,
                        rotation: 0,
                        progress: 1.0
                    };
                    
                    drawCalligraphyLStroke(p, options);
                }
            }
            
            p.draw = drawLStroke;
        });

        // Update functions
        function updateColorWheelUI() {
            // Update sliders
            document.getElementById('hue-slider').value = currentColor.h;
            document.getElementById('saturation-slider').value = currentColor.s;
            document.getElementById('brightness-slider').value = currentColor.b;
            
            // Update labels
            document.getElementById('hue-value').textContent = Math.round(currentColor.h);
            document.getElementById('saturation-value').textContent = Math.round(currentColor.s);
            document.getElementById('brightness-value').textContent = Math.round(currentColor.b);
            
            // Update color preview
            let preview = document.getElementById('color-wheel-preview');
            preview.style.backgroundColor = `hsl(${currentColor.h}, ${currentColor.s}%, ${currentColor.b}%)`;
            
            // Update color values
            let rgb = hsbToRgb(currentColor.h, currentColor.s, currentColor.b);
            let hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            
            document.getElementById('hsb-values').textContent = `${Math.round(currentColor.h)}Â°, ${Math.round(currentColor.s)}%, ${Math.round(currentColor.b)}%`;
            document.getElementById('rgb-values').textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
            document.getElementById('hex-values').textContent = hex;
        }

        function updateColorWheelLStroke() {
            if (colorWheelLStrokeSketch) {
                colorWheelLStrokeSketch.redraw();
            }
        }

        function updatePaletteLStroke() {
            if (paletteLStrokeSketch) {
                paletteLStrokeSketch.redraw();
            }
        }

        function updatePaletteUI() {
            const paletteContainer = document.getElementById('palette-swatches');
            paletteContainer.innerHTML = '';
            
            currentPalette.forEach((color, index) => {
                let swatch = document.createElement('div');
                swatch.className = `palette-swatch ${selectedPaletteIndex === index ? 'selected' : ''}`;
                swatch.style.backgroundColor = `hsl(${color.h}, ${color.s}%, ${color.b}%)`;
                swatch.title = `Color ${String.fromCharCode(65 + index)}: HSB(${Math.round(color.h)}, ${Math.round(color.s)}, ${Math.round(color.b)})`;
                
                swatch.addEventListener('click', () => {
                    selectedPaletteIndex = index;
                    updatePaletteUI();
                    updatePaletteLStroke();
                    
                    // Update palette color values
                    const selectedColor = currentPalette[selectedPaletteIndex];
                    let rgb = hsbToRgb(selectedColor.h, selectedColor.s, selectedColor.b);
                    
                    document.getElementById('selected-color-label').textContent = String.fromCharCode(65 + index);
                    document.getElementById('palette-hsb-values').textContent = `${Math.round(selectedColor.h)}Â°, ${Math.round(selectedColor.s)}%, ${Math.round(selectedColor.b)}%`;
                    document.getElementById('palette-rgb-values').textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                });
                
                paletteContainer.appendChild(swatch);
            });
            
            // Update selected color info
            if (currentPalette.length > 0) {
                const selectedColor = currentPalette[selectedPaletteIndex];
                let rgb = hsbToRgb(selectedColor.h, selectedColor.s, selectedColor.b);
                
                document.getElementById('selected-color-label').textContent = String.fromCharCode(65 + selectedPaletteIndex);
                document.getElementById('palette-hsb-values').textContent = `${Math.round(selectedColor.h)}Â°, ${Math.round(selectedColor.s)}%, ${Math.round(selectedColor.b)}%`;
                document.getElementById('palette-rgb-values').textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
            }
        }

        // Event listeners
        document.getElementById('hue-slider').addEventListener('input', (e) => {
            currentColor.h = parseFloat(e.target.value);
            updateColorWheelUI();
            updateColorWheelLStroke();
        });

        document.getElementById('saturation-slider').addEventListener('input', (e) => {
            currentColor.s = parseFloat(e.target.value);
            updateColorWheelUI();
            updateColorWheelLStroke();
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            currentColor.b = parseFloat(e.target.value);
            updateColorWheelUI();
            updateColorWheelLStroke();
        });

        document.getElementById('harmony-mode').addEventListener('change', (e) => {
            harmonyMode = e.target.value;
        });

        document.getElementById('generate-palette').addEventListener('click', () => {
            currentPalette = generateHarmonyPalette(harmonyMode);
            selectedPaletteIndex = 0;
            updatePaletteUI();
            updatePaletteLStroke();
        });

        // Initialize
        updateColorWheelUI();
        currentPalette = generateHarmonyPalette(harmonyMode);
        updatePaletteUI();
    </script>
</body>
</html>
